\documentclass[conference]{IEEEtran}

%%% ACF Limpar; só deixar os pacotes que são usados
%%% AAB Limpei alguns, não sei se todos!!!
%\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[binary-units=true]{siunitx}  % AAB inserido
\usepackage{enumitem}                   % AAB inserido
\usepackage{natbib}                     % AAB inserido
\usepackage{tikz}                       % AAB inserted 
\usetikzlibrary{shapes,arrows,shadows}  % AAB inserted
\usepackage{bm,bbm}                     % AAB inserted
\usepackage{subfig}                     % AAB insered
\usepackage{booktabs}                   % AAB inserido
\usepackage{url}                        % AAB inserido
\usepackage{listings}                   % AAB inserido
\usepackage{hyperref}                   % AAB inserido
\usepackage[all]{hypcap}                % AAB inserido
\setcitestyle{numbers}
\usetikzlibrary{calc,matrix,decorations.markings,decorations.pathreplacing}

\definecolor{colone}{RGB}{209,220,204}
\definecolor{coltwo}{RGB}{204,222,210}
\definecolor{colthree}{RGB}{207,233,232}
\definecolor{colfour}{RGB}{248,243,214}
\definecolor{colfive}{RGB}{245,238,197}
\definecolor{colsix}{RGB}{243,235,179}
\definecolor{colseven}{RGB}{241,231,163}
\definecolor{glyellow}{RGB}{218,165,32}
\definecolor{spgreen}{RGB}{46,139,87}
\tikzset{ 
  table/.style={
    matrix of nodes,
    row sep=-\pgflinewidth,
    column sep=-\pgflinewidth,
    nodes={rectangle,text width=2cm,align=center},
    text depth=1.25ex,
    text height=2.5ex,
    nodes in empty cells
  }
}
%
\usepackage{xcolor}

%New colors defined below
%\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},% commentstyle=\color{codegreen},
  %keywordstyle=\color{magenta},
  %numberstyle=\tiny\color{codegray},
  %stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}
%"mystyle" code listing set
\lstset{style=mystyle}
%
\renewcommand*{\familydefault}{\sfdefault}
\newcommand{\cbox}[1]{\parbox[t]{2cm}{\centering #1}}
%
\begin{document}
\title{A Container-based Proposal to Mitigate the Reproducibility Crisis in the Computer Vision Community}

%\author{\IEEEauthorblockN{Anderson A. de Borba}
%\IEEEauthorblockA{\textit{Dept. Economia} \\
%\textit{IBMEC--SP}\\
%São Paulo, Brasil \\
%anderborba@gmail.com}
%\and
%\IEEEauthorblockN{Luiz Barboza}
%\IEEEauthorblockA{\textit{CESAR School}\\
%Recife, Brasil \\
%lcbj@cesar.school}
%\and
%\IEEEauthorblockN{M. Marengoni}
%\IEEEauthorblockA{\textit{Albion College}\\
%Albion, MI,  USA\\
%mmarengoni@albion.edu}
%\and
%\IEEEauthorblockN{A. C. Frery}
%\IEEEauthorblockA{\textit{School of Mathematics and Statistics} \\
%\textit{Victoria University of Wellington}\\
%Wellington, New Zealand \\
%alejandro.frery@vuw.ac.nz}
%}
\maketitle

\begin{abstract}
The paper proposes to mitigate the reproducibility crisis in the computer vision community. The existence of various algorithms, methods, and databases continuously published in different media strongly contributes to the reproducibility crisis of scientific research.

Making the databases and codes employed available is very important to strengthen the reliability and development of research in the Computer Vision community.

For this reason, we propose and describe two techniques. The first technique uses Git/Github technology to make project data available; it is essential to conduct research when collaborators are in different locations. The second technique is a container technology that makes the results of scientific research strongly portable and reproducible. The Docker application manages the container technology by generating an image, stored and made available in the Dockerhub repository, facilitating moving container images.
 
With the techniques defined, we show the routines to reproduce scientific research and end by proposing some discussions and conclusions to encourage the application of these technologies to reproduce results in Computer Vision. 
\end{abstract}
\begin{IEEEkeywords}
Reproducibility, Github, Contêineres, Docker and Dockerhub 
\end{IEEEkeywords}

\section{Introdução}
O presente artigo propõe usar a tecnologia de contêineres com o objetivo de mitigar a crise de reprodutibilidade na comunidade de Visão Computacional. Crise que abrange várias áreas de pesquisas científicas, como podemos ver no artigo \citep{nat_baker}. Adicionalmente, descrevemos o uso do Git/Github e dos contêineres como meio de ajudar na reprodutibilidade das pesquisas científicas.

Destacamos os seguintes fatos: 
\begin{itemize}
	\item A reportagem da revista \textit{Nature}, encontrada em \cite{nat_baker}, cita que por volta de $70\%$ dos pesquisadores entrevistados não conseguiram reproduzir resultados publicados em artigos científicos. O artigo destaca outro dado interessante, a afirmação que mais da metade dos pesquisadores não reproduziram seus próprios resultados.
	\item Informação semelhante a encontrada no artigo \citep{nat_baker} está des\-crita no artigo \citep{br}, o qual menciona que cerca de $75\%$ dos pesquisadores encontraram pro\-blemas ao tentar reproduzir resultados de artigos publicados em importantes revistas científicas na área de sensoriamento remoto, mais especificamente na área de imagem SAR (\textit{Synthetic Aperture Radar}) a qual podemos considerar uma subárea da Visão Computacional.
	\item Ao analisar as publicações do congresso WVC (Workshop de Visão Computacional), em anos anteriores, constatamos que poucos participantes disponibilizarão os códigos usados para gerar os resultados dos artigos. Calculamos a porcentagem dos artigos que disponibilizaram os códigos no repositório \url{https://github.com/}, considerada uma boa prática de reprodutibilidade dos resultados, e obtivemos as seguintes valores: no ano de 2016 $3.3\%$, no ano de 2019 $8.4\%$, e no ano de 2020 $11.5\%$. Notamos uma evolução com o passar dos anos, entretanto, esse porcentual ainda é baixo perante o volume de estudos desenvolvidos.
\end{itemize}

Na comunidade científica, no últimos anos têm surgindo boas iniciativas para mitigar a crise da reprodutibilidade coma as mencionadas no trabalho disponível em \url{http://www.repositorio.ufal.br/jspui/handle/riufal/3254}. Destacaremos três iniciativas importantes:
\begin{itemize}
	\item O IPOL (\textit{Image Processing On Line}) é considerado um dos jornais científicos pioneiros a se com\-prometer com a reprodutibilidade na área de processamento de imagem, veja em \url{http://www.ipol.im/}. 
	\item O \textit{ReScience journal} é um jornal aberto com revisão por pares voltado para pesquisa computacional reprodutível. O objetivo desse jornal é incentivar a reprodução das pesquisas científicas, veja em \url{http://rescience.github.io/}.   
	\item O \textit{Code ocean} é uma plataforma de reprodutibilidade computacional baseada em tecnologia de nuvem, onde podemos depositar a pesquisa e organizar o fluxo de trabalhos. O objetivo desse serviço é tornar a pesquisa visível para a comunidade, fortalecendo o ambiente colaborativo para que o desenvolvimento das pesquisas sejam mais consistentes e rápidas. Veja em \url{https://codeocean.com/}.
\end{itemize}

Outra iniciativa importante pode ser encontrado na referência \citep{fgmed} na qual aponta diretrizes para um sistema de selos ajustado as especificidades da comunidade de sensoriamento remoto. Tal sistema visa reconhecer o nível de reprodutibilidade da pesquisa científica. 

Dentro desse contexto, a ideia principal do presente artigo é reproduzir os experimentos numéricos do artigo \citep{bmf_2019}. As metodologias empregadas para a detecção de evidências de bordas e fusão dessas informações podem ser encontradas nas referências \citep{bmf_2019}, \citep{bmf_2020} e \citep{borba_tese}.    

Para alcançar o objetivo de reprodutibilidade da pesquisa descrita no artigo \citep{bmf_2019}, vamos usar duas tecnologias, o Git/Github e os contêineres, gerenciado pelo software Docker. O procedimento de usar o Git/Github difere da tecnologia dos contêineres. No Git/Github, que é um controlador de versões e repositório de arquivos, temos que baixar os códigos e a base de dados para um computador e gerenciar as tarefas para viabilizar a execução dos códigos, por exemplo, instalar e verificar as versões dos softwares necessários para a execução dos códigos. Enquanto na tecnologia dos contêineres podemos embalar no contêiner um sistema operacional (SO), códigos construídos para obter os resultados do artigo citado, definir as versões dos softwares necessários para executar os códigos e habilitar um servidor web onde podemos visualizar as imagens com os resultados. Portando, como vantagem dos contêineres, temos uma estrutura portável e independente para reproduzir os resultados. Como desvantagem dos contêineres podemos citar a maior complexidade com relação ao Git/Github em deixar ambos operacionais.
       
Para construir uma versão reprodutível do artigo \citep{bmf_2019} usamos o repositório \url{https://github.com/} no qual disponibilizamos as bases de dados e os códigos necessários para a pesquisa, e o aplicativo Docker \citep{Merkel} para gerenciamento da tecnologia dos contêineres \citep{linux_cont}. Para armazenar e disponibilizar a imagem do contêiner gerada pelo aplicativo Docker utilizamos o repositório de imagens chamado de Docker hub, que pode ser acessado em \url{https://hub.docker.com/}. Nessas metodologias controlamos todos os processos, desde o armazenamento dos dados até a reprodução dos resultados do artigo selecionado. 

Esse artigo está estruturado da seguinte forma: Na seção \ref{bd} descrevemos a base de dados (imagem) usada para a reprodutibilidade dos resultados. Na seção \ref{metodologia} mostramos as metodologias aplicadas para a detecção de bordas. A estrutura do processo de reprodutibilidade está descrita na seção \ref{reprod}. Os resultados  são mostrados na seção \ref{resultados}. Para finalizar propomos algumas discussões na seção \ref{discussao}. 
\section{Base de dados}\label{bd}
No presente trabalho usamos como base de dados a imagem da região de Flevoland com dimensão $750\times 1024$ píxeis é uma imagem capturada pelo sensor AIRSAR com banda-L. A imagem tem 4 visadas, 9 canais com resolução de aproximadamente \SI{12,10}{\meter} na direção azimutal e \SI{6,6}{\meter} na direção lateral do sensor. A decomposição de Pauli da imagem capturada no sensor é mostrada na Figura \ref{flevoland_4_look}. 
%
\begin{figure}[htb!]
	\centering
	\includegraphics[width=1.0\linewidth]{img_pauli_flev}%
	\caption{Imagem da região de Flevoland}
\label{flevoland_4_look}
\end{figure}
%
\section{Metodologia}\label{metodologia}
A metologia que usamos segue o seguinte procedimento:
\begin{enumerate}[label=(\roman*)]
	\item \label{item:obj_i}  Especificar manualmente ou automaticamente a região de interesse ROI;\index{ROI}
	\item \label{item:obj_ii} Em cada ROI calcular o centro de massa e, a partir desse ponto, traçar retas radiais cruzando duas amostras distintas. O artigo \cite{gmbf} propõe um método para garantir que cruzamos duas amostras. 
	Nas radiais serão extraídas informações para o passo \ref{item:obj_iii};
	\item \label{item:obj_iii} Nos dados extraídos em cada reta radial o método Estimativa de máxima verossimilhança (MLE) é aplicado para estimar o ponto de transição entre duas amostras, chamado de evidência de borda;
	\item  \label{item:obj_iv} Métodos de fusão são aplicados nas evidências de bordas obtidas em cada canal, com o objetivo de detectar as bordas na ROI escolhida.	  
\end{enumerate}
Os detalhes desse procedimento estão descritos nos artigos \citep{bmf_2019} e \citep{bmf_2020}.
%
\section{Estrutura do processo de reprodutibilidade}\label{reprod}
No trabalho \cite{bmf_2019} foi utilizado como linguagem de programação o matlab \cite{matlab} e a linguagem de programação R \cite{r_pack}. Neste trabalho fizemos a tradução dos códigos para a linguagem de programação Python \cite{py3}. A escolha por utilizar outra linguagem de programação não foi em detrimento a nenhuma das linguagem usadas anteriormente, trata-se somente de uma decisão de projeto, pois acreditamos que a reprodutibilidade não depende da linguagem de programação empregada.   
\subsection{Usando o repositório Github}
Os programas e a base de dados utilizados estão armazenados no repositório Github, no endereço eletrônico \url{https://github.com/anderborba/Codes\_wvc2021}. Para obter os resultados pode-se fazer o \textit{download}  do projeto e rodar os programas  com o comando do python \texttt{python3.7 main.py ./Data/AirSAR\_Flevoland\_Enxuto.mat}. Quando executamos o comando, o programa está apto a ler a base de dados no diretório \path{/Data}, e gravar os resultados no diretório \path{/figuras} no formato pdf. Qualquer informação sobre os códigos pode ser encontrada no projeto, incluindo as orientações para execução e reprodução. Observamos que o procedimento de execução depende da supervisão humana podendo ocorrer falhas.


 O que pode ser um ponto de falha, pode depender de execução humana. 
%
\subsection{Usando a tecnologia Docker}
Docker é um software de código aberto executado nos sistemas operacionais Linux, Windows e Mac OS, responsável pelo empacotamento dos nossos códigos e suas dependências em contêineres.

Para entender o funcionamento do software Docker, explicaremos o que são contêineres e como são usados.  Os contêineres são tecnologias que permitem empacotar e isolar aplicações juntamente com todo o seu ambiente de execução. Isto facilita a movimentação e portabilidade da aplicação para diferentes sistemas operacionais e equipamentos, mantendo a funcionalidade total da aplicação. Portanto, com o uso dos contêineres podemos garantir que nossos códigos sejam confiáveis, escaláveis e portáveis.

O Docker pode ajudar nos seguintes problemas:
\begin{enumerate}[label=(\roman*)]
	\item \label{item:docker_prob_i} Conflito de dependências -- Se existe a necessidade de executar programas com duas versões de um mesmo software podemos empacotar cada versão em um contêiner, por exemplo, temos que executar programas em duas versões diferentes do software OpenCV \cite{opencv}, podemos instalar cada versão em um contêiner diferente.  
	\item \label{item:docker_prob_ii} Dependências ausentes -- As dependências necessárias para seu software são empacotadas conjuntamente nos contêineres.  
	\item \label{item:docker_prob_iii} Diferentes plataformas -- Mover o seu software de um SO (Sistema Operacional) para outro SO pode ser um problema. O Docker resolve o problema executando o contêiner nesses diferentes sistemas operacionais. 
\end{enumerate}

Muitos desenvolvedores de software usam o Docker para simplificar o processo de construção, execução e gerenciamento de seus software. 

Podemos considerar que o Docker virtualiza um sistema operacional para usar o hardware do computador onde os contêineres serão executados. Para cada contêiner não é necessário ter um sistema operacional, veja figura \ref{fig:conteineres_flowchart}, diferença que podemos observar em relação VMs. As VMs necessitam de seu próprio sistema operacional, veja figura \ref{fig:vm_flowchart}. Assim, a principal diferença está no fato dos contêineres compartilharem o sistema operacional.

O fluxograma do sistema de contêineres pode ser visto na figura \ref{fig:conteineres_flowchart} e o fluxograma das VMs está na figura \ref{fig:vm_flowchart}. Nas figuras realizamos as seguintes abreviações: APP significam os aplicativos necessários, no nosso caso são os programas em Python que criamos para o processo de detecção de evidências de bordas e fusão das informações destas evidências. Enquanto Bins são os binários e Bibls são as bibliotecas que usamos. 
\begin{figure}[hbt]
	\centering
\begin{tikzpicture}
    \matrix (mat) [table] {
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=colseven]|      & |[fill=colseven]|  & |[fill=colseven]| \\
    |[fill=colseven]|      & |[fill=colseven]|  & |[fill=colseven]| \\
    |[fill=colseven]|       & |[fill=colseven]|   & |[fill=colseven]|\\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\    
  };
  % Vertical lines
  \draw[spgreen] (mat-1-1.north west) -- (mat-4-1.south west);
  \draw[spgreen] (mat-1-2.north west) -- (mat-4-2.south west);
  \draw[spgreen] (mat-1-3.north west) -- (mat-4-3.south west);
  \draw[spgreen] (mat-1-3.north east) -- (mat-4-3.south east);
  % Horizontal lines
  \draw[spgreen] (mat-5-1.north west) -- (mat-5-3.north east);
  \draw[spgreen] (mat-1-1.north west) -- (mat-1-3.north east);
  %
% horizontal rules
  \draw[glyellow] (mat-5-1.north west) -- (mat-5-3.north east);
  \draw[glyellow] (mat-7-1.north west) -- (mat-7-3.north east);
  \draw[glyellow] (mat-8-1.south west) -- (mat-8-3.south east);
  \draw[glyellow] (mat-10-1.south west) -- (mat-10-3.south east);
  % Vertical lines
  \draw[glyellow] (mat-5-1.north west) -- (mat-10-1.south west);
  \draw[glyellow] (mat-5-3.north east) -- (mat-10-3.south east);
  % The labels
  \node[fill=colfour] at (mat-1-1) {App A};
  \node[fill=colfour] at (mat-1-2) {App B};
  \node[fill=colfour] at (mat-1-3) {App C};
  \node[fill=colfour] at (mat-2-1) {Bins/Bibls};
  \node[fill=colfour] at (mat-2-2) {Bins/Bibls};
  \node[fill=colfour] at (mat-2-3) {Bins/Bibls};
  \node[fill=colfour] at (mat-3-1) {Contêiner 1};
  \node[fill=colfour] at (mat-3-2) {Contêiner 2};
  \node[fill=colfour] at (mat-3-3) {Contêiner 3};
  \node[fill=colfive] at (mat-5-2) {Docker};
  \node[fill=colfive] at (mat-7-2) {Sistema operacional};
  \node[fill=colfive] at (mat-9-2) {Máquina física};
  \node[rotate = 90] at ([xshift=-52pt]mat-3-1.north)
    {\textsc{Contêineres}};
  % The braces
  \draw[decorate, decoration={brace, mirror, raise=6pt}]
    (mat-1-1.north west) -- (mat-5-1.north west);
\end{tikzpicture}
    \caption{Fluxograma dos Contêineres}
	\label{fig:conteineres_flowchart}
\end{figure}
%
\begin{figure}[hbt]
	\centering
	%\resizebox{.8\columnwidth}{!}{%
\begin{tikzpicture}
    \matrix (mat) [table] {
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|      & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=colseven]|      & |[fill=colseven]|  & |[fill=colseven]| \\
    |[fill=colseven]|      & |[fill=colseven]|  & |[fill=colseven]| \\
    |[fill=colseven]|       & |[fill=colseven]|   & |[fill=colseven]|\\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\    
  };
  \node[fill=red!40!white] at (mat-3-1) {SO VM 1};
  \node[fill=red!40!white] at (mat-3-2) {SO VM 2};
  \node[fill=red!40!white] at (mat-3-3) {SO VM 3};
  % Vertical lines
  \draw[spgreen] (mat-1-1.north west) -- (mat-4-1.south west);
  \draw[spgreen] (mat-1-2.north west) -- (mat-4-2.south west);
  \draw[spgreen] (mat-1-3.north west) -- (mat-4-3.south west);
  \draw[spgreen] (mat-1-3.north east) -- (mat-4-3.south east);
  % Horizontal lines
  \draw[spgreen] (mat-5-1.north west) -- (mat-5-3.north east);
  \draw[spgreen] (mat-1-1.north west) -- (mat-1-3.north east);
 %
% horizontal rules
  \draw[glyellow] (mat-5-1.north west) -- (mat-5-3.north east);
  \draw[glyellow] (mat-7-1.north west) -- (mat-7-3.north east);
  \draw[glyellow] (mat-8-1.south west) -- (mat-8-3.south east);
  \draw[glyellow] (mat-10-1.south west) -- (mat-10-3.south east);
  % Vertical lines
  \draw[glyellow] (mat-5-1.north west) -- (mat-10-1.south west);
  \draw[glyellow] (mat-5-3.north east) -- (mat-10-3.south east);
  % The labels
  \node[fill=colfour] at (mat-1-1) {App A};
  \node[fill=colfour] at (mat-1-2) {App B};
  \node[fill=colfour] at (mat-1-3) {App C};
  \node[fill=colfour] at (mat-2-1) {Bins/Bibls};
  \node[fill=colfour] at (mat-2-2) {Bins/Bibls};
  \node[fill=colfour] at (mat-2-3) {Bins/Bibls};
  \node[fill=colfive] at (mat-5-2) {Hypervisor};
  \node[fill=colfive] at (mat-7-2) {Sistema operacional};
  \node[fill=colfive] at (mat-9-2) {Máquina física};
  \node[rotate = 90] at ([xshift=-52pt]mat-3-1.north)
    {\textsc{Máquina Virtual - VM}};
  % The braces
  \draw[decorate, decoration={brace, mirror, raise=6pt}]
    (mat-1-1.north west) -- (mat-7-1.north west);
\end{tikzpicture}
%}
    \caption{Fluxograma das máquinas virtuais}
	\label{fig:vm_flowchart}
\end{figure}
\subsection{Obter a imagem do contêiner e reproduzir os resultados}\label{obter_imagem}
Nesta seção, vamos descrever como podemos obter e reproduzir os resultados do trabalho \cite{bmf_2019}. O pré-requisito comum para os sistemas operacionais Linux, Mac OS, e windows é a instalação do software Docker.

Com o Docker instalado nos respectivos sistema o\-peracionais podemos seguir o seguinte procedimento:
\begin{enumerate}[label=(\roman*)]
	\item \label{item:linux_i} \texttt{docker pull quantpolsar/polsar\_fusion}. Comando para baixar a imagem Docker que está no repositório \url{https://hub.docker.com/}.  
	\item \label{item:linux_ii} \texttt{docker run -e DATA=./Data/AirSAR\_Flevo\-land\_Enxuto.mat -p 8080:80 quantpolsar/polsar\_fusion}. Comando para rodar o Docker com o parâmetros \texttt{DATA} definindo sua base de dados, ou seja, a imagem PolSAR. Bem como o parâmetro \texttt{-p 8080:80} que associa uma porta física do SO hospedeiro a porta virtual na qual a aplicação está rodando dentro do contêiner.  
	\item \label{item:linux_iii} As imagens com as bordas detectadas são disponibilizadas em um servidor web no contêiner. Elas podem ser acessadas através de um navegador de internet digitando o seguinte endereço \texttt{http://localhost:8080/imagens/}.
	\item \label{item:linux_iv} \texttt{docker ps}. Comando do Docker para a obtenção do número do processo.
	\item  \label{item:linux_v} \texttt{docker kill número do processo}. Comando para encerrar todo o processo. 	  
\end{enumerate}

Além do acesso às imagens com bordas detectadas via servidor web, é possível ter acesso a todos os códigos e base de dados, executando o container de maneira interativa (parâmetro \texttt{-it}) \texttt{docker run -e DATA=./Data/AirSAR\_Flevoland\_Enxuto.mat -p 8080:80 -it --entrypoint=/bin/bash quantpolsar/polsar\_fusion} alternativamente ao passo descrito no item \ref{item:linux_ii}. Esse processo deve ser executado quando encerramos os processos do item \ref{item:linux_i} até \ref{item:linux_v}. Com isso, você estará dentro do contêiner e poderá encontrar os códigos em python na raiz do SO, encontrar a base de dados, e as figuras geradas, respectivamente nos caminhos \texttt{/Data} e \texttt{/figuras}. Adicionalmente, observamos que o passo no item \ref{item:linux_ii} vai congelar o terminal com o endereço que deve ser acessado para analisar os resultados nas figuras com as imagens PolSAR. Para descongelar o processo basta abrir outro terminal, e executar os passos dos itens \ref{item:linux_iv} e \ref{item:linux_v}.

\subsection{A imagem Docker}
A imagem Docker é construída a partir de um arquivo de definição legível por humanos e por máquinas, chamado Dockerfile. Observamos que este processo é usado somente para gerar a imagem Docker. A seção \ref{obter_imagem} pode ser executada de forma independente.

A lista \ref{lst:dockerfile} mostra a estrutura do Dockerfile
\begin{lstlisting}[caption=Estrutura do Dockerfile, label={lst:dockerfile}]
FROM ubuntu:18.04
COPY . /
RUN apt-get update -y && apt-get install -y python3-dev python3-pip
RUN apt-get install -y nginx
RUN ln -s /figuras /var/www/html/imagens
RUN echo "<meta http-equiv='refresh' content='0;URL=http://localhost:8080/imagens/'/>" > /var/www/html/index.html
RUN pip3 install scikit-image
ENV DATA ./Data/AirSAR_Flevoland_Enxuto.mat
RUN python3 main.py $DATA
EXPOSE 80
CMD echo "Acesse http://localhost:8080" && nginx -g 'daemon off;'
\end{lstlisting}

Vamos fazer uma breve descrição para cada linha do arquivo Dockerfile da lista \ref{lst:dockerfile}:
\begin{enumerate}
	\item \label{item:docker_1} Define o SO.
	\item \label{item:docker_2} Copia todos os arquivos para o projeto Docker.
	\item \label{item:docker_3} Instala a linguagem de programação python.
	\item \label{item:docker_4} Instala um servidor web para visualizar as figuras.
	\item  \label{item:docker_5} Realiza um link para as imagens geradas.
	\item  \label{item:docker_6} Cria uma página em html para visualizar as figuras.
	\item  \label{item:docker_7} Instala as bibliotecas python usadas nos códigos.
	\item  \label{item:docker_8} Define a base de dados.
	\item  \label{item:docker_9} Comando em python que roda os programas.
	\item  \label{item:docker_10} Define uma porta interna para o contêiner.
	\item  \label{item:docker_11} Gera uma mensagem indicando como acessar as figuras e habilita um servidor web para mostrar as mesmas. 
\end{enumerate}

A figura \ref{fig:conteineres_flowchart_work} mostra a estrutura do contêiner que usamos para reproduzir os resultados do artigo \cite{bmf_2019}. 
\begin{figure}[hbt]
	\centering
	%\resizebox{.8\columnwidth}{!}{%
\begin{tikzpicture}
    \matrix (mat) [table] {
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=coltwo]|       & |[fill=coltwo]|   & |[fill=coltwo]|     \\
    |[fill=colseven]|      & |[fill=colseven]|  & |[fill=colseven]| \\
    |[fill=colseven]|      & |[fill=colseven]|  & |[fill=colseven]| \\
    |[fill=colseven]|       & |[fill=colseven]|   & |[fill=colseven]|\\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\
    |[fill=colseven]|     & |[fill=colseven]| & |[fill=colseven]|    \\    
  };
  % Vertical lines
  \draw[spgreen] (mat-1-1.north west) -- (mat-4-1.south west);
  \draw[spgreen] (mat-1-3.north east) -- (mat-4-3.south east);
  % Horizontal lines
  \draw[spgreen] (mat-5-1.north west) -- (mat-5-3.north east);
  \draw[spgreen] (mat-1-1.north west) -- (mat-1-3.north east);
  %
% horizontal rules
  \draw[glyellow] (mat-5-1.north west) -- (mat-5-3.north east);
  \draw[glyellow] (mat-7-1.north west) -- (mat-7-3.north east);
  \draw[glyellow] (mat-8-1.south west) -- (mat-8-3.south east);
  \draw[glyellow] (mat-10-1.south west) -- (mat-10-3.south east);
  % Vertical lines
  \draw[glyellow] (mat-5-1.north west) -- (mat-10-1.south west);
  \draw[glyellow] (mat-5-3.north east) -- (mat-10-3.south east);
  % The labels
  \node[fill=colfour] at (mat-1-2) {Aplicativos};
  \node[fill=colfour] at (mat-2-2) {Bins/Bibls};
  \node[fill=colfour] at (mat-3-2) {Contêiner};
  \node[fill=colfive] at (mat-5-2) {Docker};
  \node[fill=colfive] at (mat-7-2) {Sistema operacional};
  \node[fill=colfive] at (mat-9-2) {Máquina física};
  \node[rotate = 90] at ([xshift=-52pt]mat-3-1.north)
    {\textsc{Contêineres}};
  % The braces
  \draw[decorate, decoration={brace, mirror, raise=6pt}]
    (mat-1-1.north west) -- (mat-5-1.north west);
\end{tikzpicture}
%}
    \caption{Fluxograma usado no Docker}
	\label{fig:conteineres_flowchart_work}
\end{figure}
Com o Dockerfile construído, rodamos o seguintes comandos do Docker para gerar a imagem. Primeiro, usamos o comando \texttt{docker build . -t quantpolsar/polsar\_fusion} para gerar a imagem Docker, depois, usamos \texttt{docker push quantpolsar/polsar\_fusion} para armazenar a imagem no repositório \url{https://hub.docker.com/}. 
%
\section{Resultados}\label{resultados}
As figuras apresentadas nessa seção foram produzidas pelo sistema de reprodutibilidade usando a tecnologia baseada em contêineres. Figuras idênticas foram obtidas pelo sistema de reprodutibilidade baseada no Git/Github. 

%Os métodos apresentados no presente artigo foram reproduzidos e executados com um computador Intel\copyright\ Core i7-9750HQ CPU  \SI{2.6}{\gibi\hertz} \SI{16}{\gibi\byte}. 

Esses métodos tomaram como referência a região de interesse (FLEV-ROI) destacada na Figura~\ref{flevoland_radial_4_look_crop}. A figura também mostra as radiais usadas para extrair informações da imagens.
\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.8\linewidth]{flevoland_radial_4_look_black_crop}%
	\caption{Região de interesse da imagem Flevoland}
\label{flevoland_radial_4_look_crop}
\end{figure}

As Figuras~\ref{evidencias_hh_hv_vv}\subref{evidencias_hh_hv_vv:a}, \ref{evidencias_hh_hv_vv}\subref{evidencias_hh_hv_vv:b}, e~\ref{evidencias_hh_hv_vv}\subref{evidencias_hh_hv_vv:c} mostram, respectivamente, as evidências de bordas nos canais~$\text{hh}$, $\text{hv}$,~e~$\text{vv}$, obtidas pelo usando o procedimento descrito na seção~\ref{metodologia}. 
\begin{figure}[hbt!]
    \subfloat[Canal $\text{hh}$ \label{evidencias_hh_hv_vv:a}]{%
    	\includegraphics[width=0.32\linewidth]{flevoland_hh_evid_param_L_mu_14_pixel_crop_py}
     	}
    \subfloat[Canal $\text{hv}$ \label{evidencias_hh_hv_vv:b}]{%
       	\includegraphics[width=0.32\linewidth]{flevoland_hv_evid_param_L_mu_14_pixel_crop_py}
     	}
    \subfloat[Canal $\text{vv}$ \label{evidencias_hh_hv_vv:c}]{%
       	\includegraphics[width=0.32\linewidth]{flevoland_vv_evid_param_L_mu_14_pixel_crop_py}
     	}
    \caption{Evidências de bordas para os três canais de intensidades na FLEV-ROI}
    \label{evidencias_hh_hv_vv} 
\end{figure}

Figuras~\ref{fusion_met}\subref{fusion_met:a}, \subref{fusion_met:b}, \subref{fusion_met:c}, e~\subref{fusion_met:d} mostram os resultados numéricos para os métodos propostos de fusão de evidência de bordas. 
\begin{figure}[hbt!]
	\centering
     \subfloat[Fusão por média\label{fusion_met:a}]{%
       \includegraphics[width=0.5\linewidth]{flevoland_fus_media_param_L_mu_14_pixel_crop_py}
     }
     \subfloat[Fusão SWT\label{fusion_met:b}]{%
       \includegraphics[width=0.5\linewidth]{flevoland_fus_swt_param_L_mu_14_pixel_crop_py}
     }\\
     \subfloat[Fusão PCA \label{fusion_met:c}]{%
       %\includegraphics[width=0.2\textwidth]{example-image-a}
       \includegraphics[width=0.5\linewidth]{flevoland_fus_pca_param_L_mu_14_pixel_crop_py}       
     }
     \subfloat[Fusão E-ROC\label{fusion_met:d}]{%
       \includegraphics[width=0.5\linewidth]{flevoland_fus_roc_param_L_mu_14_pixel_crop_py}
     }\\
%     \subfloat[Fusão MR-SWT \label{fusion_met:e}]{%
%       \includegraphics[width=0.3\linewidth]{flevoland_fus_swt_param_L_mu_14_pixel_crop_py}
%     }
%     \subfloat[Fusão MR-SVD\label{fusion_met:f}]{%
%       \includegraphics[width=0.3\linewidth]{flevoland_fus_svd_param_L_mu_14_pixel_crop_py}
%     }
     \caption{Métodos de fusão para a região FLEV-ROI}
     \label{fusion_met}
\end{figure}

Observamos que informações sobre eficiência e acurácia dos métodos podem ser obtidas nos artigos \citep{bmf_2019} e \citep{bmf_2020}.
%
\section{Discussão e Conclusões}\label{discussao}
Os dois procedimentos utilizados alcançaram o objetivo de reproduzir os resultados da detecção de bordas. Desta forma, destacamos a importância do uso desses procedimentos no desenvolvimento de novas pesquisas. 

O procedimento de usar o Github como repositório da base de dados e dos códigos é uma boa prática para alcançar a reprodutibilidade dos resultados. Porém, a responsabilidade de execução dos processos são centradas no usuário, e pode acarretar problemas na adequação de compiladores e suas bibliotecas. 

A utilização dos contêineres mostraram-se confiáveis e portáveis, pois, cada contêiner possui a estrutura adequada para rodar os programas. Lembrando que definimos no Dockerfile toda a estrutura que precisamos, o SO, os códigos e o servidor web para visualizar os arquivos no formato PDF (Portable Document Format).  

A portabilidade foi testada usando o procedimento dos contêineres com o auxílio do Docker nos principais sistemas operacionais, Linux, MacOS, e Windows e em computadores com diferentes configurações de hardware. Conseguimos reproduzir os mesmos resultados do artigo de referência.

Na criação da imagem Docker usamos somente softwares livres e de fácil acesso ao usuário.

A tecnologia dos contêineres gerenciada pelo software Docker pode ser entendida no trabalho de duas formas: 
\begin{itemize}
	\item Como está definido na lista \ref{lst:dockerfile} chamamos de execução regular. Podemos entender como um processo limitado onde não estamos hábil a modificar a base de dados (imagem) e a ROI definida. Portanto, esse procedimento reproduz o resultado do artigo de referência.  
	\item O Docker apresenta a forma interativa, usando o parâmetro \texttt{-it} fornecendo assim maior flexibilidade para o usuário. Neste caso temos acesso ao sistema operacional Linux definido para o contêiner, portanto, podemos inserir nova base de dados, definir a ROI, e consultar os código fontes  construídos durante a pesquisa para o artigo de referência. Nesse caso, os métodos de detecção de evidências de bordas e fusão dessas evidências podem ser usado como base para novas pesquisas, ou os métodos podem ser usados para estudos comparativos.       
\end{itemize}

A facilidade de obter o Docker para diferentes sistemas operacionais e as vantagens citados nos parágrafos anteriores mostram que o uso desta tecnologia é muito conveniente. Acreditamos que com o desenvolvimento dessa tecnologia teremos plataformas melhores e mais eficientes para gerenciar os contêineres.

Finalizando, citamos a confiabilidade, eficiência, e portabilidade como fatores para ampliar o uso da tecnologia dos contêineres.
\bibliographystyle{IEEEtran}
\bibliography{bibliografia}
%\vspace{12pt}
%\color{red}
%IEEE conference templates contain guidance text for composing and formatting conference papers. Please %ensure that all template text is removed from your conference paper prior to submission to the conference. %Failure to remove the template text from your paper may result in your paper not being published.
\end{document}
